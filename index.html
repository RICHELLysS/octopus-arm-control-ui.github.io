<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Octopus Arm Vision Control</title>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #1a1a2e;
      color: #e6e6e6;
    }
    .container {
      display: flex;
      flex-direction: row;
      min-height: 100vh;
    }
    .control-panel {
      width: 320px;
      padding: 20px;
      background-color: #16213e;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .video-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      background-color: #0f3460;
    }
    .video-feed {
      width: 100%;
      aspect-ratio: 4/3; /* Match VGA aspect ratio (640x480) */
      background-color: #000;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .video-stream {
      width: auto;              
      height: 100%;              
      max-width: 100%;          
      object-fit: contain;       
      display: block;
      border: none;
    }
    .detection-results {
      background-color: #1e3a5f;
      border-radius: 8px;
      min-height: 40px;
    }
    h2 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.4em;
      color: #0077cc;
      border-bottom: 2px solid #0077cc;
      padding-bottom: 8px;
    }
    h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1em;
      color:#0077cc;
    }
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    .btn-grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      background-color: #0077cc;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 12px 10px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    button:hover {
      background-color:  #0066b3;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    button:disabled {
      background-color: #555;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .status {
      margin-bottom: 20px;
      padding: 12px;
      background-color: #1e3a5f;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .detection-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .object-box {
      position: absolute;
      border: 2px solid #00ff00;
      color: #00ff00;
      font-size: 12px;
      font-weight: bold;
      padding: 2px 4px;
      background-color: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
    }
    #autoGrabButtons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    #autoGrabButtons button {
      background-color: #33cc33;
      flex-grow: 1;
      min-width: 90px;
    }
    #autoGrabButtons button:hover {
      background-color: #28a428;
    }
    p {
      margin: 10px 0;
      line-height: 1.4;
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-weight: bold;
      display: none;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      z-index: 1000;
      transition: all 0.5s;
      opacity: 0;
      transform: translateY(-20px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .notification.show {
      opacity: 1;
      transform: translateY(0);
    }
    .confidence-high {
      border-color: #00ff00;
      box-shadow: 0 0 4px #00ff00;
    }
    .confidence-medium {
      border-color: #ffff00;
      box-shadow: 0 0 4px #ffff00;
    }
    .confidence-low {
      border-color: #ff6600;
      box-shadow: 0 0 4px #ff6600;
    }
    .controls-section {
      background-color: #1e3a5f;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .controls-title {
      font-size: 1.1em;
      margin-top: 0;
      margin-bottom: 12px;
      color: #0077cc;
    }

    .state-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }

    .state-btn {
      background-color: #3498db;
      color: white;
      padding: 8px;
      font-size: 14px;
      border-radius: 5px;
    }

    .state-btn:hover {
      background-color: #2980b9;
    }

    .emergency-btn {
      background-color: #e74c3c;
      font-weight: bold;
      letter-spacing: 1px;
    }

    .emergency-btn:hover {
      background-color: #c0392b;
    }

    .auto-mode-active {
      background-color: #27ae60;
    }

    .auto-mode-active:hover {
      background-color: #219653;
    }
    
    /* Responsive styles for different screen sizes */
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
      .control-panel {
        width: auto;
        order: 2;
      }
      .video-container {
        order: 1;
      }
      .video-feed {
        height: 50vh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="control-panel">
      <h2>Octopus Arm Control</h2>
      
      <div class="status">
        <p>State: <span id="connectionState">no device connection</span></p>
        <p>Server: <span id="serverInfo">192.168.43.91:81</span></p>
      </div>
      
      <div class="btn-grid">
        <button id="connectBtn" onclick="connectWebSocket()">Connect Control System</button>
      </div>
      
      <div class="controls-section">
        <p class="controls-title">Manual Control</p>
        <div class="btn-grid-2">
          <button onclick="sendCommand('L1R1')" disabled>Roll Left</button>
          <button onclick="sendCommand('L2R2')" disabled>Roll Right</button>
        </div>
        
        <div class="btn-grid-2">
          <button onclick="sendCommand('L1S2')" disabled>Spin Left</button>
          <button onclick="sendCommand('S1R2')" disabled>Spin Right</button>
        </div>
        
        <div class="btn-grid-2">
          <button onclick="sendCommand('L2S2')" disabled>Loose Left</button>
          <button onclick="sendCommand('S1R1')" disabled>Loose Right</button>
        </div>
        
        <div class="btn-grid">
          <button onclick="sendCommand('S1S2')" disabled>Stop</button>
        </div>
      </div>
      
      <div class="controls-section">
        <p class="controls-title">Computer Vision Control</p>
        <div class="btn-grid">
          <button id="scanBtn" onclick="scan()" disabled>Scan Environment</button>
          <div id="autoGrabButtons">
             <div class="detection-results">
              <div id="detectionData">No objects detected yet.</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="video-container">
      <h2>Computer Vision Module</h2>
      <div class="video-feed">
        <img id="videoStream" class="video-stream" alt="Camera Stream" onerror="handleVideoError()">
        <div class="detection-overlay" id="detectionOverlay"></div>
        <div class="loading" id="loadingIndicator">Analyzing environment...</div>
      </div>
      <!-- Auto Control Section moved here, below video stream -->
   <div class="controls-section">
      <p class="controls-title">Auto Control System</p>
      <p>Automated movement based on state transitions</p>
    
      <!-- Auto control toggle -->
      <div class="btn-grid">
        <button id="autoModeBtn" onclick="toggleAutoMode()" disabled>Enable Auto Mode</button>
      </div>
    
    <!-- State selection for manual transitions -->
    <div class="state-selection" id="stateSelectionContainer" style="display: none; margin-top: 15px;">
      <p>Current State: <span id="currentState">0</span></p>
      <p>Target State:</p>
      <div class="state-grid">
        <button onclick="selectTargetState(0)" class="state-btn">0</button>
        <button onclick="selectTargetState(1)" class="state-btn">1</button>
        <button onclick="selectTargetState(2)" class="state-btn">2</button>
        <button onclick="selectTargetState(3)" class="state-btn">3</button>
        <button onclick="selectTargetState(4)" class="state-btn">4</button>
        <button onclick="selectTargetState(5)" class="state-btn">5</button>
        <button onclick="selectTargetState(6)" class="state-btn">6</button>
        <button onclick="selectTargetState(7)" class="state-btn">7</button>
        <button onclick="selectTargetState(8)" class="state-btn">8</button>
      </div>
    </div>
    
    <!-- Emergency stop button -->
      <div class="btn-grid" style="margin-top: 15px;">
        <button id="emergencyStopBtn" onclick="emergencyStop()" disabled class="emergency-btn">EMERGENCY STOP</button>
      </div>
    </div>
  </div>
</div>
  
  <div id="notification" class="notification"></div>

  <script>
    // Configuration
    const CONFIG = {
      // ESP32 CAM stream address - update with your ESP32-CAM IP
      streamAddress: "http://192.168.43.172:81/stream",
      
      // ESP32 CAM object detection address
      detectionAddress: "http://192.168.43.172/detect",
      
      // WebSocket configuration - updated with your ESP32 controller IP
      websocketUrl: "ws://192.168.43.91:81",
      
      // Stream refresh interval (in milliseconds)
      streamRefreshInterval: 30000,
      
      // Confidence thresholds for visual indicators
      confidenceThresholds: {
        high: 0.75,
        medium: 0.5,
        low: 0.3
      }
    };
    
    // State
    let state = {
      isConnected: false,
      detected: [],
      streamRefreshTimer: null,
      socket: null,
      lastGrabbedObject: null,
      connectionAttempts: 0,
      maxReconnectAttempts: 3
    };
    
    // DOM Elements
    const elements = {
      videoStream: null,
      connectionState: null,
      connectBtn: null,
      controlButtons: null,
      detectionOverlay: null,
      detectionData: null,
      autoGrabButtons: null,
      emptyLabel: null,
      scanBtn: null,
      loadingIndicator: null,
      notification: null,
      serverInfo: null
    };
    
    // Helper function to show notifications
    function showNotification(message, duration = 3000) {
      elements.notification.textContent = message;
      elements.notification.classList.add('show');
      
      setTimeout(() => {
        elements.notification.classList.remove('show');
      }, duration);
    }
    
    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
      // Get DOM elements
      elements.videoStream = document.getElementById('videoStream');
      elements.connectionState = document.getElementById('connectionState');
      elements.connectBtn = document.getElementById('connectBtn');
      elements.controlButtons = document.querySelectorAll('.btn-grid button, .btn-grid-2 button');
      elements.detectionOverlay = document.getElementById('detectionOverlay');
      elements.detectionData = document.getElementById('detectionData');
      elements.autoGrabButtons = document.getElementById('autoGrabButtons');
      elements.emptyLabel = document.getElementById('emptyLabel');
      elements.scanBtn = document.getElementById('scanBtn');
      elements.loadingIndicator = document.getElementById('loadingIndicator');
      elements.notification = document.getElementById('notification');
      elements.serverInfo = document.getElementById('serverInfo');
      
      // Update server info display
      elements.serverInfo.textContent = CONFIG.websocketUrl.replace('ws://', '');
      
      // Set up video stream
      setupVideoStream();
      
      // Check if WebSockets are supported
      if (!window.WebSocket) {
        showNotification("WebSockets are not supported in your browser. Please use a modern browser.", 10000);
        elements.connectBtn.disabled = true;
        elements.connectionState.textContent = "WebSockets not supported";
      }
      
      // Handle window resize for detection overlay
      window.addEventListener('resize', function() {
        if (state.detected && state.detected.length > 0) {
          drawDetectionBoxes();
        }
      });

      // Check device status automatically
      checkStatus();
    });
    
    // Check ESP32 status
    async function checkStatus() {
      try {
        const response = await fetch(`http://192.168.43.172/status`);
        if (response.ok) {
          const data = await response.json();
          if (data.status === "ok") {
            showNotification("Camera is online and ready", 3000);
          }
        }
      } catch (error) {
        console.error("Camera status check failed:", error);
        showNotification("Camera appears to be offline. Check connections.", 5000);
      }
    }
    
    // Set up video stream
    function setupVideoStream() {
      // For img tag approach (more efficient than iframe)
      elements.videoStream.src = CONFIG.streamAddress;
      
      // Clear any existing refresh timer
      if (state.streamRefreshTimer) {
        clearInterval(state.streamRefreshTimer);
      }
      
      // Periodically refresh the stream to prevent freezing
      state.streamRefreshTimer = setInterval(() => {
        if (!document.hidden) { // Only refresh if page is visible
          refreshVideoStream();
        }
      }, CONFIG.streamRefreshInterval);
    }
    
    // Refresh the video stream
    function refreshVideoStream() {
      elements.videoStream.src = CONFIG.streamAddress + '?t=' + new Date().getTime();
    }
    
    // Handle video loading error
    function handleVideoError() {
      console.log("Video stream error, attempting to reconnect...");
      setTimeout(() => {
        refreshVideoStream();
      }, 1000);
    }
    
    // Connect to WebSocket
    function connectWebSocket() {
      if (state.isConnected) {
        // If already connected, disconnect
        if (state.socket) {
          state.socket.close();
          state.socket = null;
        }
        updateConnectionState(false);
        return;
      }
      
      elements.connectBtn.disabled = true;
      elements.connectBtn.textContent = "Connecting...";
      
      try {
        state.socket = new WebSocket(CONFIG.websocketUrl);
        
        // Connection opened
        state.socket.addEventListener('open', (event) => {
          console.log("WebSocket connected");
          updateConnectionState(true);
          showNotification("Connected to Octopus Arm control system!", 3000);
          state.connectionAttempts = 0;
          
          // Automatically refresh the video stream
          refreshVideoStream();
        });
        
        // Listen for messages
        state.socket.addEventListener('message', (event) => {
          console.log('Message from server:', event.data);
          handleServerMessage(event.data);
        });
        
        // Listen for errors
        state.socket.addEventListener('error', (event) => {
          console.error('WebSocket error:', event);
          showNotification("Connection error occurred. Try reconnecting.", 5000);
          updateConnectionState(false);
        });
        
        // Connection closed
        state.socket.addEventListener('close', (event) => {
          console.log('WebSocket connection closed');
          showNotification("Connection closed", 3000);
          updateConnectionState(false);
          
          // Try to reconnect (max 3 attempts)
          if (state.connectionAttempts < state.maxReconnectAttempts) {
            state.connectionAttempts++;
            console.log(`Attempting to reconnect (${state.connectionAttempts}/${state.maxReconnectAttempts})...`);
            setTimeout(() => {
              if (!state.isConnected) {
                connectWebSocket();
              }
            }, 3000);
          }
        });
      } catch (error) {
        console.error('Connection Error:', error);
        showNotification("Connection failed: " + error.message, 5000);
        updateConnectionState(false);
      } finally {
        elements.connectBtn.disabled = false;
      }
    }

     // State transition and timing tables
  const stateTransitionTable = [
    ['-', 'a', 'b', '5d', '6c', 'a', 'b', '3c', '4d'],
    ['be', '-', 'b', '5d', '6c', 'b', 'b', '3c', '4d'],
    ['be', 'a', '-', '5d', '6c', 'g', 'g', '3c', '4d'],
    ['gfe', 'a', '6b', '6c', 'g', 'f', 'c', '4d', '-'],
    ['fge', '5a', 'b', '5d', 'c', 'g', 'gb', '3c', 'd'],
    ['fe', 'a', 'b', '5d', '6c', '-', 'b', '3c', '4d'],
    ['ge', 'a', 'b', '5d', 'c', 'a', '-', '3c', '4d'],
    ['fge', 'a', 'fb', 'fd', '6cg', 'fa', 'bf', '-', '3c'],
    ['fge', 'ga', 'b', '5d', 'gc', 'g', 'gd', '3c', '-']
  ];
  
  const timingTable = [
    ['-', 12, 12, 14, 14, 3, 3, 22, 22],
    [12, '-', 23, 29, 29, 8, 16, 25, 31],
    [12, 19, '-', 29, 15, 16, 8, 31, 25],
    [14, 14, 20, '-', 23, 7, 6, 10, 33],
    [14, 20, 14, 23, '-', 7, 7, 33, 10],
    [4, 10, 15, 9, 15, '-', 7, 19, 25],
    [4, 15, 10, 15, 9, 7, '-', 25, 19],
    [10, 13, 13, 6, 23, 13, 13, '-', 32],
    [12, 16, 8, 23, 5, 13, 13, 32, '-']
  ];
  
  // Command mappings
  const commandMap = {
    'a': 'L1R1', // Roll Left
    'b': 'L2R2', // Roll Right
    'c': 'L1S2', // Spin Left
    'd': 'S1R2', // Spin Right
    'e': 'S1S2', // Stop
    'f': 'L2S2', // Loose Left
    'g': 'S1R1'  // Loose Right
  };
  
  // State variables
  let states = {
    autoModeEnabled: false,
    currentState: 0,
    targetState: null,
    transitionInProgress: false,
    emergencyStopTriggered: false
  };
  
  // Initialize when page loads
  document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners and initialize UI for auto control
    document.getElementById('currentState').textContent = states.currentState;
    
    // Add auto control elements to the existing state object
    states.autoModeEnabled = false;
    states.currentState = 0;
    states.targetState = null;
    states.transitionInProgress = false;
    states.emergencyStopTriggered = false;
  });
  
  // Toggle auto mode
  function toggleAutoMode() {
    if (!state.isConnected) {
      showNotification("Please connect to the control system first");
      return;
    }
    
    states.autoModeEnabled = !states.autoModeEnabled;
    const autoModeBtn = document.getElementById('autoModeBtn');
    const stateSelectionContainer = document.getElementById('stateSelectionContainer');
    const emergencyStopBtn = document.getElementById('emergencyStopBtn');
    
    if (states.autoModeEnabled) {
      autoModeBtn.textContent = "Disable Auto Mode";
      autoModeBtn.classList.add('auto-mode-active');
      stateSelectionContainer.style.display = 'block';
      emergencyStopBtn.disabled = false;
      
      // Send message to the server that auto mode is enabled
      sendAutoModeState(true);
      
      showNotification("Auto Mode enabled. Select a target state.");
    } else {
      autoModeBtn.textContent = "Enable Auto Mode";
      autoModeBtn.classList.remove('auto-mode-active');
      stateSelectionContainer.style.display = 'none';
      emergencyStopBtn.disabled = true;
      
      // Send message to the server that auto mode is disabled
      sendAutoModeState(false);
      
      // Cancel any transitions in progress
      states.transitionInProgress = false;
      states.targetState = null;
      
      showNotification("Auto Mode disabled.");
    }
  }
  
  // Send auto mode state to the server
  function sendAutoModeState(enabled) {
    if (states.socket && states.socket.readyState === WebSocket.OPEN) {
      const modeCommand = {
        autoMode: enabled,
        currentState: states.currentState
      };
      states.socket.send(JSON.stringify(modeCommand));
    }
  }
  
  // Select target state
  function selectTargetState(targetState) {
    if (!states.autoModeEnabled || states.transitionInProgress) {
      return;
    }
    
    if (targetState === states.currentState) {
      showNotification("Already at state " + targetState);
      return;
    }
    
    states.targetState = targetState;
    states.transitionInProgress = true;
    
    // Send state transition request to the server
    if (states.socket && states.socket.readyState === WebSocket.OPEN) {
      const transitionCommand = {
        command: "AUTO_TRANSITION",
        fromState: states.currentState,
        toState: states.targetState
      };
      states.socket.send(JSON.stringify(transitionCommand));
      
      showNotification(`Starting transition from state ${state.currentState} to state ${state.targetState}`);
    }
  }
  
  // Emergency stop
  function emergencyStop() {
    if (!state.isConnected) {
      return;
    }
    
    states.emergencyStopTriggered = true;
    states.transitionInProgress = false;
    
    // Send emergency stop command
    if (states.socket && states.socket.readyState === WebSocket.OPEN) {
      const emergencyCommand = {
        command: "EMERGENCY_STOP"
      };
      states.socket.send(JSON.stringify(emergencyCommand));
    }
    
    showNotification("EMERGENCY STOP triggered!", 5000);
  }
  
  // Update current state (called from message handler)
  function updateCurrentState(newState) {
    states.currentState = newState;
    document.getElementById('currentState').textContent = newState;
    
    // If we've reached the target state, transition is complete
    if (newState === state.targetState) {
      states.transitionInProgress = false;
      showNotification(`Reached target state ${newState}`);
    }
  }
    
    // Handle server messages
    function handleServerMessage(message) {
      try {
        // Try to parse as JSON
        const data = JSON.parse(message);
        
        if (data.status) {
          // Status update from the device
          console.log('Status update:', data.status);
          
          if (data.status !== "state normal") {
            showNotification("Device: " + data.status);
          }
        } else if (data.response) {
          // Command response
          console.log('Command response:', data.response);
          showNotification(data.response);
        } else if (data.detectionResult) {
          // Object detection results
          console.log('Detection results received via WebSocket');
          
          // Parse the results
          let detectionData;
          try {
            detectionData = JSON.parse(data.detectionResult);
          } catch (e) {
            // If the result is already an object and not a string
            detectionData = data.detectionResult;
          }
          
          console.log("Detected objects via WebSocket:", detectionData);
          
          // Process the detection results
          processDetectionResults(detectionData);
          
          // Hide loading indicator
          elements.loadingIndicator.style.display = "none";
          elements.scanBtn.disabled = false;
          if (data.stateUpdate) {
              updateCurrentState(data.stateUpdate.currentState);
        
              if (data.stateUpdate.transitionComplete) {
                states.transitionInProgress = false;
              }
          }

        }
      } catch (e) {
        // If not JSON, just log the raw message
        console.log('Raw message from server:', message);
        
        if (message.includes("state normal")) {
          // Everything is normal, no need to show notification
        } else {
          showNotification("Device: " + message);
        }
      }
    }
    
    // Process detection results (used by both WebSocket and HTTP methods)
    function processDetectionResults(data) {
      // Store detection results
      state.detected = data;
      
      // Update the UI with the detection results
      updateUI();
      drawDetectionBoxes();
      updateDetectionResults();
      
      if (data.length > 0) {
        showNotification(`Detected ${data.length} object(s) in view. Select one to grab.`);
      } else {
        showNotification("No objects detected in the current view.");
      }
    }
    
    // Update connection state UI
    function updateConnectionState(connected) {
      state.isConnected = connected;
      const autoModeBtn = document.getElementById('autoModeBtn');
      const emergencyStopBtn = document.getElementById('emergencyStopBtn');
    
      
      if (connected) {
        elements.connectionState.textContent = "connected";
        elements.connectBtn.textContent = "Disconnect";
        elements.connectBtn.style.backgroundColor = "#cc3c54";
        
        // Enable control buttons
        elements.controlButtons.forEach(button => {
          button.disabled = false;
        });
        
        // Enable scan button
        elements.scanBtn.disabled = false;

        autoModeBtn.disabled = false;
        if (states.autoModeEnabled) {
            emergencyStopBtn.disabled = false;
        }
      } else {
        autoModeBtn.disabled = true;
        emergencyStopBtn.disabled = true;
        elements.connectionState.textContent = "no device connection";
        elements.connectBtn.textContent = "Connect Control System";
        elements.connectBtn.style.backgroundColor = "#e94560";
        
        // Disable control buttons
        elements.controlButtons.forEach(button => {
          button.disabled = true;
        });
        
        // Disable scan button
        elements.scanBtn.disabled = true;
        
        // Reset WebSocket object
        state.socket = null;
        if (states.autoModeEnabled) {
          states.autoModeEnabled = false;
          const autoModeBtn = document.getElementById('autoModeBtn');
          autoModeBtn.textContent = "Enable Auto Mode";
          autoModeBtn.classList.remove('auto-mode-active');
          document.getElementById('stateSelectionContainer').style.display = 'none';
        }

        
      }
    }
    
    // Send command via WebSocket
    async function sendCommand(command) {
      if (!state.isConnected || !state.socket) {
        showNotification("Please connect to the control system first");
        return;
      }
      
      try {
        const button = document.querySelector(`button[onclick="sendCommand('${command}')"]`);
        if (button) {
          button.disabled = true;
          const originalText = button.textContent;
          button.textContent = "Sending...";
          
          // Create command object
          const commandObj = {
            command: command
          };
          
          // Send command to WebSocket
          state.socket.send(JSON.stringify(commandObj));
          
          // Visual feedback that command was sent
          setTimeout(() => {
            button.textContent = "âœ“ " + originalText;
            setTimeout(() => {
              button.textContent = originalText;
              button.disabled = false;
            }, 500);
          }, 100);
        }
      } catch (error) {
        console.error("Error sending command:", error);
        showNotification("Failed to send command: " + error.message);
        
        // Reset button state if there was an error
        const button = document.querySelector(`button[onclick="sendCommand('${command}')"]`);
        if (button) {
          button.disabled = false;
          button.textContent = button.textContent.replace("Sending...", "");
        }
      }
    }
    
    // Object detection
    async function scan() {
      if (!state.isConnected) {
        showNotification("Please connect to the control system first");
        return;
      }
      
      try {
        // Disable scan button and show loading indicator
        elements.scanBtn.disabled = true;
        elements.loadingIndicator.style.display = "block";
        elements.loadingIndicator.textContent = "Analyzing environment...";
        elements.detectionData.textContent = "Running object detection...";
        
        // Clear previous detection boxes
        elements.detectionOverlay.innerHTML = '';
        
        // Try to get detection via WebSocket first (more efficient)
        if (state.socket && state.socket.readyState === WebSocket.OPEN) {
          // Send detection request via WebSocket
          const detectCommand = {
            action: "detect"
          };
          state.socket.send(JSON.stringify(detectCommand));
          
          // Set a timeout in case the WebSocket doesn't respond
          setTimeout(async () => {
            if (elements.loadingIndicator.style.display === "block") {
              console.log("WebSocket detection request timed out, falling back to HTTP");
              await fetchDetectionViaHTTP();
            }
          }, 5000);
          
          // The result will be handled by the WebSocket message handler
          return;
        } else {
          // Fall back to HTTP request
          await fetchDetectionViaHTTP();
        }
      } catch (error) {
        console.error(error.message);
        elements.detectionData.textContent = "Error: " + error.message;
        showNotification("Detection failed: " + error.message);
        
        // Clear any previous detection data
        state.detected = [];
        updateUI();
      } finally {
        // Make sure scan button is re-enabled
        setTimeout(() => {
          elements.scanBtn.disabled = false;
          elements.loadingIndicator.style.display = "none";
        }, 5000);
      }
    }
    
    // Fetch detection results via HTTP
    async function fetchDetectionViaHTTP() {
      const response = await fetch(CONFIG.detectionAddress);
      if (!response.ok) {
        throw new Error(`Could not fetch results of object detection: ${response.status}`);
      }
      
      const data = await response.json();
      console.log("Detected objects via HTTP:", data);
      
      // Process the detection results
      processDetectionResults(data);
    }
    
    // Update UI with detected objects
    function updateUI() {
      // Remove any existing buttons
      while (elements.autoGrabButtons.firstChild) {
        elements.autoGrabButtons.removeChild(elements.autoGrabButtons.firstChild);
      }
      
      // Add a button for each detected object
      const seenObjects = [];
      
      if (!state.detected || state.detected.length === 0) {
        // If there were no objects detected, add the empty label
        elements.autoGrabButtons.appendChild(elements.emptyLabel);
        return;
      }
      
      state.detected.forEach(obj => {
        if (!seenObjects.includes(obj.name)) {
          seenObjects.push(obj.name);
          const theButton = document.createElement("button");
          theButton.dataset.object = obj.name;
          theButton.textContent = obj.name;
          theButton.setAttribute("onclick", `grab("${obj.name}")`);
          
          // Add confidence class for visual indication
          if (obj.conf >= CONFIG.confidenceThresholds.high) {
            theButton.classList.add("confidence-high");
          } else if (obj.conf >= CONFIG.confidenceThresholds.medium) {
            theButton.classList.add("confidence-medium");
          } else {
            theButton.classList.add("confidence-low");
          }
          
          elements.autoGrabButtons.appendChild(theButton);
        }
      });
    }
    
    // Draw bounding boxes for detected objects
    function drawDetectionBoxes() {
      elements.detectionOverlay.innerHTML = '';
      
      if (!state.detected || state.detected.length === 0) {
        return;
      }
      
      const videoFeed = document.querySelector('.video-feed');
      const videoWidth = videoFeed.clientWidth;
      const videoHeight = videoFeed.clientHeight;
      
      state.detected.forEach(obj => {
        // Create a box for each detected object
        const box = document.createElement('div');
        box.className = 'object-box';
        
        // Add confidence class for visual indication
        if (obj.conf >= CONFIG.confidenceThresholds.high) {
          box.classList.add("confidence-high");
        } else if (obj.conf >= CONFIG.confidenceThresholds.medium) {
          box.classList.add("confidence-medium");
        } else {
          box.classList.add("confidence-low");
        }
        
        // Get normalized coordinates from the bbox property
        const { x, y, w, h } = obj.bbox;
        
        // Convert normalized coordinates [0,1] to pixel values
        const left = x * videoWidth;
        const top = y * videoHeight;
        const width = w * videoWidth;
        const height = h * videoHeight;
        
        // Set position and size
        box.style.left = `${left}px`;
        box.style.top = `${top}px`;
        box.style.width = `${width}px`;
        box.style.height = `${height}px`;
        
        // Add label with confidence
        const confidence = Math.round(obj.conf * 100);
        box.textContent = `${obj.name} (${confidence}%)`;
        
        // Highlight if this was the last grabbed object
        if (obj.name === state.lastGrabbedObject) {
          box.style.borderColor = "#e94560";
          box.style.boxShadow = "0 0 8px #e94560";
        }
        
        // Add to overlay
        elements.detectionOverlay.appendChild(box);
      });
    }
    
    // Update detection results text area
    function updateDetectionResults() {
      if (!state.detected || state.detected.length === 0) {
        elements.detectionData.textContent = "No objects detected. Try adjusting camera position or lighting conditions.";
        return;
      }
      
      // Group objects by name
      const uniqueObjects = {};
      
      state.detected.forEach(obj => {
        if (!uniqueObjects[obj.name]) {
          uniqueObjects[obj.name] = [];
        }
        uniqueObjects[obj.name].push(obj);
      });
      
      // Generate HTML for the detection results
      let detectionHtml = '<ul>';
      
      for (const [name, objects] of Object.entries(uniqueObjects)) {
        // Calculate average confidence for this object type
        const avgConfidence = objects.reduce((sum, obj) => sum + obj.conf, 0) / objects.length;
        const confidencePercent = Math.round(avgConfidence * 100);
        
        let confidenceClass = "";
        if (avgConfidence >= CONFIG.confidenceThresholds.high) {
          confidenceClass = "confidence-high";
        } else if (avgConfidence >= CONFIG.confidenceThresholds.medium) {
          confidenceClass = "confidence-medium";
        } else {
          confidenceClass = "confidence-low";
        }
        
        detectionHtml += `<li><strong class="${confidenceClass}">${name}</strong>: ${objects.length} instance(s) detected, avg. confidence: ${confidencePercent}%</li>`;
      }
      
      detectionHtml += '</ul>';
      
      // Add total count and instructions
      detectionHtml = `<p>Total objects detected: <strong>${state.detected.length}</strong></p>` + 
                      detectionHtml + 
                      `<p>Click on an object button to make the Octopus Arm automatically move to grab it.</p>`;
      
      // Update the display
      elements.detectionData.innerHTML = detectionHtml;
    }
    
    // Grab function
    function grab(objectName) {
      console.log(`Grabbing object: ${objectName}`);
      
      if (!state.isConnected) {
        showNotification("Please connect to the control system first");
        return;
      }
      
      // Find the object with this name in the detected list
      const object = state.detected.find(obj => obj.name === objectName);
      
      if (!object) {
        showNotification(`Object ${objectName} not found in detection data`);
        return;
      }
      
      // Set as last grabbed object for highlighting
      state.lastGrabbedObject = objectName;
      
      // Calculate grab position (center of the object)
      const centerX = object.bbox.x + (object.bbox.w / 2);
      const centerY = object.bbox.y + (object.bbox.h / 2);
      
      // Determine which movement commands to send based on object position
      moveToPosition(centerX, centerY, objectName);
    }
    
    // Move to position
    async function moveToPosition(x, y, objectName) {
      try {
        // Disable the button during operation
        const button = document.querySelector(`button[data-object="${objectName}"]`);
        if (button) {
          button.disabled = true;
          button.textContent = `Moving to ${objectName}...`;
        }
        
        // Use the AUTO command for more efficient and precise movement
        if (state.socket && state.socket.readyState === WebSocket.OPEN) {
          // Create AUTO command with object name and coordinates
          const autoCommand = {
            command: `AUTO:${objectName}:${x}:${y}`
          };
          
          // Send command to WebSocket
          state.socket.send(JSON.stringify(autoCommand));
          showNotification(`Automatically positioning to grab ${objectName}...`);
          
          // Set a timeout to re-enable the button
          setTimeout(() => {
            if (button) {
              button.disabled = false;
              button.textContent = objectName;
            }
            // Redraw detection boxes to highlight grabbed object
            state.lastGrabbedObject = objectName;
            drawDetectionBoxes();
          }, 3000);
          
          return;
        }
        
        // Fall back to manual movement if WebSocket not available
        const centerX = 0.5;
        const tolerance = 0.05;
        const distanceX = x - centerX;
        
        // First, handle horizontal alignment
        if (Math.abs(distanceX) > tolerance) {
          // Need to move horizontally
          if (distanceX < 0) {
            // Object is to the left of center
            await sendCommand('L1S2'); // Spin Left
            showNotification(`Moving left to reach ${objectName}...`);
          } else {
            // Object is to the right of center
            await sendCommand('S1R2'); // Spin Right
            showNotification(`Moving right to reach ${objectName}...`);
          }
          
          // Stop after movement
          setTimeout(async () => {
            await sendCommand('S1S2'); // Stop
            
            // Wait a moment before attempting grab
            setTimeout(() => {
              // Finally execute grab
              showNotification(`Grabbing ${objectName}!`);
              
              // Re-enable the button
              if (button) {
                button.disabled = false;
                button.textContent = objectName;
              }
              
              // Update last grabbed object and redraw
              state.lastGrabbedObject = objectName;
              drawDetectionBoxes();
            }, 500);
          }, 2000); // Move for 2 seconds
        } else {
          // Object is already centered horizontally
          showNotification(`Object ${objectName} is centered. Grabbing!`);
          
          // Re-enable the button
          if (button) {
            button.disabled = false;
            button.textContent = objectName;
          }
          
          // Update last grabbed object and redraw
          state.lastGrabbedObject = objectName;
          drawDetectionBoxes();
        }
      } catch (error) {
        console.error(error.message);
        showNotification(`Failed to grab ${objectName}: ${error.message}`);
        
        // Re-enable the button
        const button = document.querySelector(`button[data-object="${objectName}"]`);
        if (button) {
          button.disabled = false;
          button.textContent = objectName;
        }
      }
    }
  </script>
</body>
</html>